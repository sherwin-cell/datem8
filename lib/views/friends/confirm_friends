import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_database/firebase_database.dart';

class ConfirmFriendRequest extends StatelessWidget {
  final String currentUserId;
  final String requesterId;

  const ConfirmFriendRequest({
    Key? key,
    required this.currentUserId,
    required this.requesterId,
  }) : super(key: key);

  /// ‚úÖ Accept the friend request
  Future<void> acceptRequest() async {
    final firestore = FirebaseFirestore.instance;
    final db = FirebaseDatabase.instance.ref();

    try {
      // Batch write for both users to ensure atomicity
      final batch = firestore.batch();

      final currentRef = firestore
          .collection('friends')
          .doc(currentUserId)
          .collection('list')
          .doc(requesterId);

      final requesterRef = firestore
          .collection('friends')
          .doc(requesterId)
          .collection('list')
          .doc(currentUserId);

      batch.set(currentRef, {
        'mutual': true,
        'timestamp': FieldValue.serverTimestamp(),
      });

      batch.set(requesterRef, {
        'mutual': true,
        'timestamp': FieldValue.serverTimestamp(),
      });

      // Delete the friend request
      final query = await firestore
          .collection('friend_requests')
          .where('from', isEqualTo: requesterId)
          .where('to', isEqualTo: currentUserId)
          .get();

      for (var doc in query.docs) {
        batch.delete(doc.reference);
      }

      await batch.commit();

      // Create chat in Realtime Database if it doesn't exist
      final chatId = currentUserId.hashCode <= requesterId.hashCode
          ? '$currentUserId-$requesterId'
          : '$requesterId-$currentUserId';

      final chatRef = db.child('chats').child(chatId);
      final chatSnapshot = await chatRef.get();

      if (!chatSnapshot.exists) {
        await chatRef.set({
          'participants': {currentUserId: true, requesterId: true},
          'timestamp': ServerValue.timestamp,
          'lastMessage': 'You are now friends! üëã',
          'lastMessageSenderId': currentUserId,
        });

        await chatRef.child('messages').push().set({
          'senderId': currentUserId,
          'text': 'You are now friends! üëã',
          'timestamp': ServerValue.timestamp,
        });
      }
    } catch (e) {
      debugPrint('‚ùå Error accepting friend request: $e');
    }
  }

  /// ‚úÖ Reject the friend request
  Future<void> rejectRequest() async {
    final firestore = FirebaseFirestore.instance;

    try {
      final query = await firestore
          .collection('friend_requests')
          .where('from', isEqualTo: requesterId)
          .where('to', isEqualTo: currentUserId)
          .get();

      for (var doc in query.docs) {
        await doc.reference.delete();
      }
    } catch (e) {
      debugPrint('‚ùå Error rejecting friend request: $e');
    }
  }

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        ElevatedButton(
          onPressed: acceptRequest,
          style: ElevatedButton.styleFrom(backgroundColor: Colors.green),
          child: const Text('Accept'),
        ),
        const SizedBox(width: 8),
        ElevatedButton(
          onPressed: rejectRequest,
          style: ElevatedButton.styleFrom(backgroundColor: Colors.redAccent),
          child: const Text('Reject'),
        ),
      ],
    );
  }
}
